# -*- coding: utf-8 -*-
"""calib.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18tLDFx-M-Pypc1xdMl-wMhAISxX1fe2y
"""

from skimage.io import imread, imshow
from skimage import transform
import matplotlib.pyplot as plt
import numpy as np

"""# **calib 1**

"""

img = imread('4_45.jpg')
imshow(img)

import cv2
import numpy as np


src = np.array([518,359,
                803, 358,
                724, 555,
                394, 555,]).reshape((4, 2))
#destination coordinates
dst = np.array([1282, 405,
                1699, 416,
                1698, 851,
                1249, 853,]).reshape((4, 2))
#using skimage’s transform module where ‘projective’ is our desired parameter
'''H, _ = cv2.findHomography(src, dst)'''
tform = transform.estimate_transform('projective', src, dst)
tf_img = transform.warp(img, tform.inverse)
#plotting the transformed image
fig, ax = plt.subplots()
ax.imshow(tf_img)
_ = ax.set_title('projective transformation')



# Compute the homography matrix
H, _ = cv2.findHomography(src, dst, cv2.RANSAC, 5.0)

# Print the homography matrix
print("Homography Matrix:")
print(H)

import cv2
import numpy as np
from google.colab.patches import cv2_imshow


# Load the input image
input_image = cv2.imread("4_45.jpg")

# Define the homography matrix (replace with your own matrix)


# Apply the projective transformation
output_image = cv2.warpPerspective(input_image, H, (input_image.shape[1], input_image.shape[0]))

# Display the input and output images
cv2_imshow(input_image)
cv2_imshow(output_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

print('actual image')
img_90 = imread('4_90.jpg')
imshow(img_90)

print(H)

pixel_coordinates = np.array([
    [518, 359, 1],
    [803, 358, 1],
    [724, 555, 1],
    [394, 555, 1]
])
world_coordinates = np.dot(H, pixel_coordinates.T).T
lambda_scale = 0.0068
print('world_coordinates')
for row in world_coordinates:
    formatted_row = [f"{element:.2f}" for element in row]
    print(" ".join(formatted_row))
normalized_coordinates = [[x / z, y / z, 1] for x, y, z in world_coordinates]

# Print the normalized coordinates
print('NORMALIZED COORDINATES')
for coord in normalized_coordinates:
    print(coord)
# Normalize by lambda to get real-world coordinates
real_world_coordinates = [[x * lambda_scale, y * lambda_scale, 1] for x, y, _ in normalized_coordinates]

# Print the results
print("Image Pixel Coordinates:")
print(pixel_coordinates)
print("\nReal-World Coordinates (in meters):")
for coord in real_world_coordinates:
    print(coord)

"""# **TEST IMAGE**"""

pixel_coordinates=np.array([[1442,611,1],[1171,484,1],[1449,485,1],[1468,717,1],[1127,716,1]])
world_coordinates = np.dot(H, pixel_coordinates.T).T
lambda_scale = 0.0068
print('world_coordinates')
for row in world_coordinates:
    formatted_row = [f"{element:.2f}" for element in row]
    print(" ".join(formatted_row))
normalized_coordinates = [[x / z, y / z, 1] for x, y, z in world_coordinates]

# Print the normalized coordinates
print('NORMALIZED COORDINATES')
for coord in normalized_coordinates:
    print(coord)
# Normalize by lambda to get real-world coordinates
real_world_coordinates = [[x * lambda_scale, y * lambda_scale, 1] for x, y, _ in normalized_coordinates]

# Print the results
print("Image Pixel Coordinates:")
print(pixel_coordinates)
print("\nReal-World Coordinates (in meters):")
for coord in real_world_coordinates:
    print(coord)

from skimage.io import imread, imshow
img_test=imread('test_1.5.jpg')
imshow(img_test)

"""# calib **2**"""

import cv2
import numpy as np


src = np.array([1838,684,
                2256, 696,
                1832, 913,
                2312, 933,]).reshape((4, 2))
#destination coordinates
dst = np.array([1698, 813,
                2368, 1047,
                1498, 1415,
                2184, 1691,]).reshape((4, 2))
#using skimage’s transform module where ‘projective’ is our desired parameter

H_10, _ = cv2.findHomography(src, dst, cv2.RANSAC, 5.0)

# Print the homography matrix
print("Homography Matrix:")
print(H_10)

import cv2
import numpy as np


src = np.array([1910,1223,
                2251, 1245,
                1913, 1468,
                2270, 1474,]).reshape((4, 2))
#destination coordinates
dst = np.array([1743,952,
                2206, 1100,
                1604, 1354,
                2069, 1530,
                ]).reshape((4, 2))
#using skimage’s transform module where ‘projective’ is our desired parameter

H_14, _ = cv2.findHomography(src, dst, cv2.RANSAC, 5.0)

# Print the homography matrix
print("Homography Matrix:")
print(H_14)

pixel_coordinates = np.array([
   [1693,818,1],
                [1489, 1421,1]

])
world_coordinates = np.dot(H_10, pixel_coordinates.T).T
lambda_scale = 0.0029
print('world_coordinates')
for row in world_coordinates:
    formatted_row = [f"{element:.2f}" for element in row]
    print(" ".join(formatted_row))
normalized_coordinates = [[x / z, y / z, 1] for x, y, z in world_coordinates]

# Print the normalized coordinates
print('NORMALIZED COORDINATES')
for coord in normalized_coordinates:
    print(coord)
# Normalize by lambda to get real-world coordinates
real_world_coordinates = [[x * lambda_scale, y * lambda_scale, 1] for x, y, _ in normalized_coordinates]

# Print the results
print("Image Pixel Coordinates:")
print(pixel_coordinates)
print("\nReal-World Coordinates (in meters):")
for coord in real_world_coordinates:
    print(coord)

pixel_coordinates = np.array([
   [3515,496,1],
                [3662, 556,1],

])
world_coordinates = np.dot(H_14, pixel_coordinates.T).T
lambda_scale = 0.0044
print('world_coordinates')
for row in world_coordinates:
    formatted_row = [f"{element:.2f}" for element in row]
    print(" ".join(formatted_row))
normalized_coordinates = [[x / z, y / z, 1] for x, y, z in world_coordinates]

# Print the normalized coordinates
print('NORMALIZED COORDINATES')
for coord in normalized_coordinates:
    print(coord)
# Normalize by lambda to get real-world coordinates
real_world_coordinates = [[x * lambda_scale, y * lambda_scale, 1] for x, y, _ in normalized_coordinates]

# Print the results
print("Image Pixel Coordinates:")
print(pixel_coordinates)
print("\nReal-World Coordinates (in meters):")
for coord in real_world_coordinates:
    print(coord)

"""# **calib3**"""

import cv2
import numpy as np


src = np.array([1372,737,
                1880, 729,
                1877, 1069,
                1302, 1069,]).reshape((4, 2))
#destination coordinates
dst = np.array([1492,788,
                2295, 788,
                2307, 1591,
                1490, 1595,
                ]).reshape((4, 2))
#using skimage’s transform module where ‘projective’ is our desired parameter

H_3_10, _ = cv2.findHomography(src, dst, cv2.RANSAC, 5.0)

# Print the homography matrix
print("Homography Matrix:")
print(H_3_10)

import cv2
import numpy as np


src = np.array([1470,1195,
                1913, 1181,
                1899, 1527,
                1417, 1527,]).reshape((4, 2))
#destination coordinates
dst = np.array([1609,863,
                2198, 868,
                2198, 1454,
                1600, 1463
                ,]).reshape((4, 2))
#using skimage’s transform module where ‘projective’ is our desired parameter

H_3_14, _ = cv2.findHomography(src, dst, cv2.RANSAC, 5.0)

# Print the homography matrix
print("Homography Matrix:")
print(H_3_14)

"""# **test**"""

import math
pixel_coordinates = np.array([
   [1788,1697,1],
                [2320, 1664,1],
   [1880,2076,1],
   [2450,2005,1]

])
world_coordinates = np.dot(H_3_10, pixel_coordinates.T).T
lambda_scale = 0.00374
print('world_coordinates')
for row in world_coordinates:
    formatted_row = [f"{element:.2f}" for element in row]
    print(" ".join(formatted_row))
normalized_coordinates = [[x / z, y / z, 1] for x, y, z in world_coordinates]

# Print the normalized coordinates
print('NORMALIZED COORDINATES')
for coord in normalized_coordinates:
    print(coord)
# Normalize by lambda to get real-world coordinates
real_world_coordinates = [[x * lambda_scale, y * lambda_scale, 1] for x, y, _ in normalized_coordinates]

# Print the results
print("Image Pixel Coordinates:")
print(pixel_coordinates)
print("\nReal-World Coordinates (in meters):")
for coord in real_world_coordinates:
    print(coord)
for i in range(len(real_world_coordinates)):
    for j in range(i+1, len(real_world_coordinates)):  # Start from the next coordinate to avoid duplicates
        x1, y1,z1 = real_world_coordinates[i]
        x2, y2,z2 = real_world_coordinates[j]

        # Calculate the distance using the Euclidean distance formula
        distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
        print(i,j ,distance)